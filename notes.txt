A. Query-level data (MANDATORY)
1Ô∏è‚É£ SQL text

Source

Dremio query history

Job profiles / system tables

REST API

Used for

Pattern detection (SELECT *, joins, filters)

Rewrite suggestions

Change diffing

Agent insights

Top slow queries

Repeated anti-patterns

High-risk SQL patterns

2Ô∏è‚É£ Query plans & profiles (goldmine üíé)

Source

Dremio Query Profile

EXPLAIN plans

Job details API

Contains

Operator tree

Row counts

Scan size

Join methods

Reflection usage

Agent insights

Partition pruning applied?

Join fan-out

Exchange / shuffle hotspots

Reflection mismatches

This is your single most important signal.

B. Metadata & catalog data
3Ô∏è‚É£ Table & dataset metadata

Source

Dremio Catalog API

Iceberg / Hive metastore

Information schema

Includes

File format

Partition columns

Sort order

Row counts

Update frequency

Agent insights

Partition misuse

Poor table design

Missing reflections

Schema evolution risks

4Ô∏è‚É£ Reflection metadata (Dremio-specific)

Source

Dremio reflection APIs

Includes

Reflection type

Refresh frequency

Usage stats

Agent insights

Unused reflections (wasted cost)

Missing reflections

Reflections that don‚Äôt match query shapes

C. Execution & resource data
5Ô∏è‚É£ Execution metrics

Source

Dremio job profiles

Cluster metrics (YARN / Kubernetes)

Includes

CPU

Memory

Disk spill

Runtime per phase

Agent insights

Memory pressure

Skewed joins

Concurrency issues

Bad query patterns during peak hours

6Ô∏è‚É£ Storage-layer metadata

Source

Object storage metrics (S3 / ADLS)

Iceberg metadata tables

Includes

File counts

File sizes

Partition layout

Snapshot history

Agent insights

Small file problems

Metadata bloat

Missing compaction

Inefficient partitioning

D. User & usage context (often overlooked)
7Ô∏è‚É£ User & workload metadata

Source

Dremio users / roles

BI tool query tags

Session metadata

Agent insights

Who runs expensive queries

Which dashboards cause load

Which teams need education vs automation

8Ô∏è‚É£ Historical baselines

Source

Stored query history

Past performance snapshots

Agent insights

Regression detection

Anomaly detection

‚ÄúThis query used to be fast‚Äù

2Ô∏è‚É£ What this enables your agent to do

Here‚Äôs the payoff.

A. Issue detection (automated)
Issue Data needed
No partition pruning Plan + metadata
Reflection unused Plan + reflection catalog
Join fan-out Plan row counts
SELECT * SQL text
Small file problem Storage metadata
VDS overuse Catalog lineage
Expensive dashboards User + query frequency
B. Root cause analysis (huge value)

Example:

‚ÄúWhy did yesterday‚Äôs dashboards slow down?‚Äù

Agent can correlate:

Query runtime ‚Üë

File count ‚Üë

New partition added

Reflection refresh failed

This is where LLM reasoning shines.
